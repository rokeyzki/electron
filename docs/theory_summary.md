# 原理 - 总结

## 代码编译阶段/CP（编译器）

* 词法语法分析
* 可执行代码生成
* 作用域/Scope规则确定
    * 全局作用域/GS
    * 函数作用域/FS
    * 块级作用域/BS（let声明的变量）
    * eval

## 代码执行阶段/EP（脚本引擎）

* 执行上下文/EC栈处理（脚本引擎以【栈/stack】的方式来处理执行上下文）
    * 执行上下文/EC创建阶段
        * 创建变量对象/VO（脚本引擎以【堆/heap】的方式来处理变量对象）
            * 创建arguments对象
            * 检查函数声明，创建属性（检查当前上下文的函数声明，也就是使用function关键字声明的函数，不包括变量函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。）
            * 检查变量声明，创建属性（检查当前上下文的变量声明，每找到一个变量声明，包括函数声明的每个参数变量，就在变量对象中以变量名建立一个属性，属性值为undefined。如果当前上下文的该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。）
        * 建立作用域链/SC（脚本引擎以【栈/stack】的方式来处理作用域链）
        * 确定this指向
            * 直接调用的函数（函数中的this指向undefined，在非严格模式下，this指向全局对象）
            * 全局环境的对象（属性中的this指向全局对象）
            * 函数环境的对象（属性中的this指向undefined，在非严格模式下，this指向全局对象）
            * 对象方法的函数（函数中的this指向所属对象）
            * 构造函数与原型方法上的this（函数中的this指向实例对象）
            * 使用call，apply显性指定this（函数中的this指向参数对象）
    * 执行上下文/EC执行阶段（所有执行上下文创建完了之后，才开始进入这个阶段）
        * 变量对象/VO转变为了活动对象/AO（未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作）
        * 执行代码（变量赋值、语句执行）
* 垃圾回收（JS的内存生命周期）
    * 分配你所需要的内存
    * 使用分配到的内存（读、写）
    * 不需要时将其释放、归还
